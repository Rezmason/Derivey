// basic definitions

function min(*a, *b) { if (a < b) return a; return b; }
function max(*a, *b) { if (b < a) return a; return b; }
function mix(*a, *b, t) { return a*(1-t) + b*t; }
function abs(*a) { if (a < 0) return -a; return a; }
function sign(*a) { if (a < 0) return -1; return 1; }
function swap(&a, &b) { var c = a; a = b; b = c; }
function operator<=>(&a, &b) { var c = a; a = b; b = c; }

//System.SetScreenMode(320,240,32);

var appname = "DRIVEY (graphic test)"
var version = "0.15";
var copyright = "¬© 2005 Mark Pursey";

	// screen saver other modes?
if (commandline.Left(3) == "/c:" || commandline >> "/p")
	return;
	
	// set up globals
with object g
{
	project = true;
	showDashboard = true;
	showHelp = 0.0;
	
	blur = false;
	wireframe = false;
	noAA = false;
	frameRate = 1.0;
	//height = 1.5;
	rearView = false;	
	zoom = 0.6;
	fisheye = 0.0;
	xfunc = true;
	roadType = 3;
	area = 0.0;
	areaLast = 0.0;

	with col {
		with sky {
			lo = 0.5 as color;
			hi = lo;
			gradient = 0.5;	// power
			}
		ground = color;
		}
	
		// colors for palette tinting
	tint = color(0.2, 0.3, 0.8);//0.5 as color;
		
	fade = 0.0;
	
	gradient = true;
	auto = true;
	cycle = 0;
	collisions = 0;
	center = point(0.5, 0.3);
	
	laneSpacing = 2;
	laneOffset = -2.5;	// north american
	mute = true;
	
	timeSlice = 0.05;
}


function LoadConfig()
{
	var cfg = LoadString("drivey.cfg");
	while (cfg != "")
	{
	
	 	if (cfg >> "map")
	 		cfg >> g.roadType;
	 	else if (cfg >> "palette_cycle")
	 		cfg >> g.cycle;
		else if (cfg >> "collisions")
			cfg >> g.collisions;
		else if (cfg >> "tint")
			cfg >> g.tint.r,cfg >> g.tint.g,cfg >> g.tint.b,g.tint *= 1.0/255;
		else if (cfg >> "usa")
			g.laneOffset = -abs(g.laneOffset);
		else if (cfg >> "aus")
			g.laneOffset = abs(g.laneOffset);
		else 
			cfg.Skip();
	}
}

function SaveConfig()
{
	var cfg = "";
	cfg += "map " + g.roadType + "\n";
	cfg += "palette_cycle " + g.cycle + "\n";
	cfg += "collisions " + g.collisions + "\n";
	cfg += "tint " + (int)(g.tint.r * 255) + " " + (int)(g.tint.g * 255) + " "  + (int)(g.tint.b * 255) + "\n";
	cfg += (g.laneOffset < 0 ? "usa" : "aus") + "\n";
	
	SaveString("drivey.cfg", cfg);
}

class world
{
	path road;
	shape walls;

}

shape theRoad;
shape theWalls;

with window win
{
	if (commandline >> "/p")
	{
		Create(160,100);
		Move(0,0);
	}
	else
	{
		Create(640,480);
		ShowCursor(false);
		FullScreen(true);
	}
	
	SetText(appname + " " + version);
	Show(true);
	//Cmd("lock syskeys");
}

// sound system

//Dx.SetWindow(win);

var& scr = win.BackBuffer();

with scr//with screen scr
{
	SetMonochrome(true);////SetTint(0, tint * 0.6, tint);
}


function ShowTitle()
{
	with scr {
		SetTint(0,0.5,1);
		rgb = 1;
		alpha = 1;
		bg = 0;
		Cls();
		}
	
	var msg = appname;
	shape s = TextShape(msg, "bold Arial");
	s.Scale(0.05);
	//s.BoxFit();
	//s.Scale(point(0.5, 0.05));
	s.ReCenter();
	s.Move(point(0.5, 0.4));
	shape x = s;
	s.Scale(win.GetDims());
	scr.Shape(s);
	
	
	shape s = TextShape(version, "bold Arial");
	//s.BoxFit();
	s.Scale(0.05);
	s.ReCenter();
	s.Move(point(0.5, 0.45));
	s.Scale(win.GetDims());
	scr.rgb = 1;
	scr.Shape(s);
	/*with scr
	{
		rgb = 1;//color(0,1,0);
		bg = 0;
		Locate(0,0);
		Print(msg);
	} */

	win.Paint(); 
	
	g.fade = 0;
	//win.Show(true);
}


string message;
function SetMessage(msg)
{
	message = msg;
	g.showHelp = 1;	// 2 seconds should be enough?

}

function DrawHelp()
{  
	if (g.showHelp > 0)
	{
		with scr
		{
			rgb = 1;
			alpha = min(1,g.showHelp);
			bg = 0;
			Locate(0,0);
			if (message.Length())
				Print(message);
			else
			{
				Print("<esc>: quit");
				Print("<home>: return to road");
				Print("W,A,S,D & Arrow keys: speed and steering control");
				Print("F1: toggle help");
				Print("F2: wireframe");
				Print("F3: toggle dashboard");
				Print("F4: rear view");
				Print("F5: toggle (awful) manual control");
				Print("F6: toggle (awful) collision detection");
				Print("F7: toggle sky gradient");
				Print("F8: switch driving side");
				Print("F9: save configuration");
				Print("F11: toggle fullscreen");
				Print("G: greyscale palette");
				Print("H: random palette");
				Print("K: toggle palette cycling");
				Print("N,M: adjust view angle");
				Print("V,B: adjust brightness");
				Print("C: add other cars");
				Print("1-4: switch environment type");
				Print("<ctrl>: super fast");
				Print("<shift>: super slow");
			}
			Cmd("font size " + Height() / 32);
			rgb = 0.5;
			bg = 0;
			Locate(0,-3);
			Print(appname + " " + version + "\n" + copyright + "\nhttp://drivey.com");
		}
	}

}

//real user.angle = 0;
//point pos.Set(0,0);
//point vel.Set(0,0);
real tt = 0;

real g_lastTime = 0;
real g_lastStep = 0.05;
real g_zoom = 1;
point  g_mid.Set(0,0);


class part : shape
{
	color rgb;
	real alpha;
	real height;
	real extrude;
	
	construct() {
rgb = 1; height = 0; extrude = 0; alpha = 1; }
}

class car
{
	vector pos;
	vector vel; 
	
	vector lastVel;
	vector lastPos;
	
	real angle;
	
	real accelerate;	// for tilting
	real brake;
	
	real tilt;
	real pitch;

	real tiltV;
	real pitchV;
	
	int	roadDir;
	real 	roadPos;
	real   stepVel;
	
	real steer;
	real steerTo;
	real steerPos;
	real steerV;
	
	bool sliding;
	real spin;	// only valid while sliding
	
	real cruise;
	
	construct() { Init(); }
	
	function Init() 
	{ 
		pos.Set(0,1,0); 
		vel.Set(0,0,0); 
		lastVel.Set(0,0,0);
		
		accelerate = 0;
		brake = 0;
		
		angle = 0;
		 
		tilt = 0; 
		pitch = 0; 
		
		tiltV = 0;
		pitchV = 0;
		
		roadPos = 0; 
		stepVel = 0;
		roadDir = -1;
		
		steer = 0; 
		steerPos = 0;
		steerTo = 0;
		steerV = 0;
		
		sliding = false;
		spin = 0;
		cruise = 120 * 1000 / 3600;	// 50 kph
	}
	
	function Collide(car &c)
	{
	
		var pd = pos - c.pos;
		var vd = vel - c.vel;
		var radius = 2.0;
		
		double dist = pd.Magnitude() - radius;
		if (dist < 0)
		{
			if ((vd ^ pd) < 0)	// closing?
			{
		
				vd = !pd * (vd ^ !pd) * 0.6;
				vel -= vd;		
				c.vel += vd;
			}
			var push = !pd * (radius - pd.Magnitude());// * 0.5;
			pos += push;
			c.pos -= push;
		}
		return dist;
	}
	
	function Collide(shape* s)
	{
	
		if (!s.Paths())
			return;
			
		var pt = M2W(s.GetNearestPoint(W2M(pos)));
		var pd = pt - pos.(vector(x,0,z));
		var radius = 1;
		
		var dist = pd.Magnitude() - radius;
		if (dist < 0)	// contact?
		{
			if ((vel ^ pd) > 0)	// hitting an obstacle? bounce off it
			{
				vel -= !pd * (vel ^ !pd) * 1.5;
			}
			var push = !pd * (radius - |pd);// * 0.5;
			pos -= push;
		}
		return dist;
	}
	
	function Dir()
	
	{
	
	   return vector(0, 0, 1).RotateY(-angle);
	}  
	
	function Advance(var t) 
	{
	
		if (t <= 0)
			return;
		
		var dir = vector(0, 0, 1).RotateY(-angle);
		
		var acc = dir * accelerate * 10 + vel * - 0.1;
		
		var oldSpin = spin;
		
		var newVel = dir * ((vel+acc*t) ^ dir);
		if (brake >= 0.9)
			newVel.Set(0,0,0);
		
		if (!sliding && (newVel - vel).Magnitude()/t > 750)	// maximum acceleration allowable?
			sliding = true;
		else if (sliding && (newVel - vel).Magnitude()/t < 50)
			sliding = false;
		//else if (sliding && (newVel - vel).Magnitude() < 25 * t)	// break into skid?
			//sliding = false;
			
		if (sliding)
		{			
			var friction = !(newVel - vel) * 20;
			//if (friction.Magnitude() < (newVel - vel).Magnitude())	// have we got this worked out now?
			vel += friction * t;
//			else 
	//			sliding = false;
		}
		
		if (!sliding)
		{
			vel = newVel;
		}
		
		spin = (vel ^ dir) * steerPos * (sliding ? 0.5 : 1.0);
		angle += spin * t;
		pos += vel * t;
		
		var velDiff = vel - lastVel;
		
		//tilt *= -1;
		tiltV += ((tiltV * -0.2) + (velDiff ^ dir.RotateY(Math.PI * -0.5)) * 0.001 / t - tilt) * t * 20;
		tilt += tiltV * t;
		//tilt /= -1;
		
		pitchV += ((pitchV * -0.2) + (velDiff ^ dir) * 0.001 / t - pitch) * t * 20;
		pitch += pitchV * t;
		             
		var diff = steerTo-steerPos;
		
		if (|diff > t * 0.05)
			diff *= t * 0.05 / |diff;
			
		steerPos += diff;//steerTo;//mix(steerPos, steerTo, Math.pow(0.9, 1.0/t));
		
		var grav = -10;
			
		pos.y = lastPos.y + lastVel.y * t + 0.5 * grav * t * t;
		vel.y = lastVel.y + grav * t;
		
		if (pos.y < 1.5)
		{
			pos.y = 1.5;
			vel.y = 0;
		}
		
		lastVel = vel;
		lastPos = pos;
	}

}
     
car user;
car other[];

LoadConfig();	// pick a road type

var road = MakeRoad();

LoadConfig();


function AddNPCCar()
{

	with other.Next()
	{
	
		var t = theRoad[0].Length() * Math.random();
		pos = M2W(theRoad[0].GetPoint(t));// + GetNormal(t)));
		//vel = !point(Math.random(),Math.random()) * 40;
		roadDir = (other.Length()&1) ? -1 : 1;
		PlaceOn(theRoad[0]);
	}
}

with shape speedoShape
{
	MakeCircle(point(0,0), 0.5);
	Outline(0.025);
	
	with shape dash
	{
		AddVertex(-0.01,-0.49);
		AddVertex(0.01,-0.49);
		AddVertex(0.01,-0.44);
		AddVertex(-0.01,-0.44);
		//AddControl(0,-0.4);
	}
	int n = 8;
	for (int i = 0; i <= n; i++)
	{
	
		shape sh = dash;
		sh.Rotate(mix(-Math.PI * 0.8, Math.PI * 0.8, (real)i / n));
		Merge(sh);
	}
}

with shape speedoNeedle
{
	
	AddVertex(-0.02,0.1);
	//AddControl(0,-0.9);
	AddVertex(-0.005,-0.4);
	AddVertex(0.005,-0.4);
	AddVertex(0.02,0.1);
	
	/*
	int n = 16;	// outer ring
	for (int i = 0; i < n; i++)
	{
		
		AddControl(point(Math.cos(i * 2 * Math.PI / n), Math.sin(i * 2 * Math.PI / n)) * 0.5);
	}
	*/
	ClosePath();
}

with shape steeringWheelShape
{
	MakeCircle(point(0,0), 0.5);
	/*
	int n = 16;	// outer ring
	for (int i = 0; i < n; i++)
	{
		
		AddControl(point(Math.cos(i * 2 * Math.PI / n), Math.sin(i * 2 * Math.PI / n)) * 0.5);
	}
	*/
	ClosePath();
	
	int n = 60;	// inner ring
	for (int i = n - 3; i > n / 2 + 2; i--)
		AddControl(point(Math.cos(i * 2 * Math.PI / n), Math.sin(i * 2 * Math.PI / n)) * ((i & 1) ? 0.435: 0.45));
		
	ClosePath();
	
	for (int i = n / 2 - 1; i > 0; i--)
		AddControl(point(Math.cos(i * 2 * Math.PI / n), Math.sin(i * 2 * Math.PI / n)) * ((i & 1) ? 0.435: 0.45));
		
	AddControl(point(0.25, 0.075));
	AddControl(point(0.125, 0.2));
	AddControl(point(-0.125, 0.2));
	AddControl(point(-0.25, 0.075));
		
	ClosePath();
	//Expand(-0.01);
}

with shape postShape
{
	MakeUnit();
	//shape a = this;
	//a.Scale(point(1, 0.2));
	//a.Move(point(0,1.1));
	//Merge(a);
	Scale(point(0.1, -0.5));
	//Outline(0.05);
	//Rotate(0.2);

}  


if (true)
{
	postShape = TextShape("w", "RoadSign");
	postShape.ReCenter();
	postShape.Move(point(0,-2));
}

array posts;
for (int i = 0; i < 100; i++)
{
	point p;
	p.y = i*8;
	if (i & 1)
		p.x = Math.sin(p.y * 0.025) * 8 + 3;
	else
		p.x = Math.sin(p.y * 0.025) * 8 - 3;
	posts[i] = p;

}

shape signShape = TextShape(appname, "bold Arial");
signShape.Scale(point(0.5,0.5));
signShape = MakeSign(signShape);

shape banner = TextShape("http://www.jujusoft.com/drivey", "Verdana");
with banner
{
	Rotate(-0.5 * Math.PI);

	BoxFit();
}

with shape carLights
{
	Init();
	
	shape sq.MakeUnit();
	
	Merge(sq);
	sq.Move(point(3,0)); 	
	Merge(sq);
	
	BoxFit();
	ReCenter();
	//MakeCircle(point(0,0), 0.5);
	Scale(point(2,0.1));
	Move(point(0,2));
}

with shape carLightPaths
{
	Init();
	
	shape sq;//.MakeUnit();
	sq.AddVertex(0,0);
	sq.AddControl(-6,13);
	sq.AddControl(4,15);
	
	Merge(sq);
	sq.Scale(point(-1,1)); 	
	sq.Invert();
	sq.Move(point(1.6,0)); 	
	Merge(sq);
	
	//BoxFit();
	//ReCenter();
	//MakeCircle(point(0,0), 0.5);
	//Scale(point(2,0.1));
	Move(point(-0.8,3));
}

with shape carTailLightShape
{
	Init();
	
	shape sq.MakeUnit();
	
	Merge(sq);
	sq.Move(point(3,0)); 	
	Merge(sq);
	
	BoxFit();
	ReCenter();
	//MakeCircle(point(0,0), 0.5);
	Scale(point(2,0.05));
	Move(point(0,-2));
}

with shape carBodyBottom
{
	Init();
	
	MakeUnit();
	
	BoxFit();
	ReCenter();
	
	//MakeCircle(point(0,0), 0.5);
	Scale(point(2,4));
}

with shape carBodyTop
{
	Init();
	
	MakeUnit();
	
	BoxFit();
	ReCenter();
	
	//MakeCircle(point(0,0), 0.5);
	Scale(point(2,3));
	Move(point(0,-0.5));
}

//var user.steer = 0.0;

int g_frames = 0;
time g_startTime.GetLocal();
real g_frameInterval = 0.01;

	// start the sound playing
//roadSound.Play();

time lastTime.GetLocal();
real lastStep = 0;
real lastJoyX = 0;

function M2W(*p)
{
	return vector(p.x, 0, p.y);

}                             
function W2M(*p)
{
	return point(p.x, p.z);

}                             

function car::PlaceOn(*rd)
{
	var t = rd.GetNearest(W2M(pos));
	var tan = !rd.GetTangent(t);
	var normal = -rd.GetNormal(t);
	if (roadDir < 0)
		tan = -tan, normal = -normal;
	
	lastPos = pos = M2W(rd.GetPoint(t) + normal * (g.laneSpacing * roadPos + g.laneOffset));
	angle = -tan.GetAngle() + Math.PI * 0.5;
	lastVel = vel = vector(0, 0, cruise).RotateY(-angle);
}

function car::AutoDrive(*aroad)
{
	with aroad
	{
		
		var dir = vel;
		if (dir.Magnitude() > 0)
			dir = !vel;
		else
			dir = vector(0, 0, 1).RotateY(-angle);
		
			// get position on road for 1 second ahead of now
					
		var lookAhead = 20;	// basic direction stuff
		var t = GetNearest(W2M(pos + dir * lookAhead));
		
		var targetDir = M2W(GetPoint(t)) - pos;
		var tangent = M2W(!GetTangent(t));
		
		if (roadDir < 0)
			tangent = -tangent;
			
		var normal = tangent.RotateY(Math.PI * 0.5);
		targetDir += normal * (g.laneSpacing * roadPos + g.laneOffset);
		
		if (targetDir.Magnitude() > 0)
			tangent = mix(tangent, targetDir, 0.05);
		
		var newAngle = W2M(tangent).GetAngle() - Math.PI * 0.5;
		newAngle = -newAngle;
		
		newAngle -= angle;
		
		while (newAngle > Math.PI)
			newAngle -= Math.PI * 2;
		while (newAngle < -Math.PI)
			newAngle += Math.PI * 2;
			
		if (|newAngle > 1)
			newAngle /= |newAngle;
			
		steerTo = newAngle / (min(targetDir.Magnitude() * 0.5, 50) + 1);// mix(steer, newAngle * 20, 0.25);
		
		if (|steerTo > 0.02)
			steerTo *= 0.02/|steerTo;
			
		
		//steerPos = steerTo;
		
		if (vel.Magnitude() < cruise)
			accelerate = 1;
		else 
			accelerate = cruise / vel.Magnitude();
	}
}     

SetMessage("ESC to quit, F1 for help\n(arrow keys adjust speed and steering)");
g.showHelp = 2;


	// main loop
while (win.IsValid())
{
	//Dx.Refresh();
		
	int key = win.GetKey();
	
	if (key <= 0)
	{
	
		// no key or maybe key release
	}
	else if (key == 112)	// F1
	{
		if (!message.Length() && g.showHelp > 1)
			g.showHelp = 0;
		else
			g.showHelp = 6;
			
		message = "";
	}
		
	else if (key == 118)	// F7
	{
	
		g.gradient = !g.gradient;
		SetMessage("gradient " + (g.gradient ? "on": "off"));
	}
	/*else if (key == 120)	// F9
	{
	
		//System.SetScreenMode(640,480,32);
		win.FullScreen(true);
	} */
	else if (key == 27)	// escape
	{
	
	  	break;
	}
	else if (key == 'C')
	{
	
		if (other.Length() > 16)
			other.Resize(0);
		else for (8)
			AddNPCCar();
		SetMessage("" + other.Length() + " cars on the road");
	}
	else if (key == 119)	// F8
	{
	
		g.laneOffset = -g.laneOffset;
		SetMessage("Driving style: " + (g.laneOffset < 0 ? "North American": "Australian"));
	}
	else if (key == 120)	// F9
	{
	
		SaveConfig();
		SetMessage("Config saved.");
	}
	else if (key == 117)	// F6
	{
	
		g.collisions = !g.collisions;
		SetMessage("collision detection " + (g.collisions ? "on (crappy)": "off"));
	}
	/*else if (key == 117)
	{
	
		g.mute = !g.mute;
		if (g.mute)
		{
			Dx.KillSound();
			SetMessage("sound off");
		}
		else
		{
			g.sounds.road = CreateSignal("(noise(0.5)@100)");
			g.sounds.engine = CreateSignal("(fm(qud@0.11,fm(sin@0.2,qud)@0.26)@300*0.05)");
			//g.sounds.engine = CreateSignal("(fm(qud,qud*0.5@0.125)@100*0.1)");
			//g.sounds.road = g.sounds.road + *g.sounds.engine;
			//g.sounds.road = 
			//g.sounds.engine = CreateSignal("(sin@50*0.25)");
				//"squ"
				//"qud"
				//"sin"
				//"mix(noise(0.5)*2, noise(0.7))"
				//"(loop(\"C:\\Dev\\JujuScripts\\games\\sound\\road.wav\")@0.0025)"
				//"wav(\"C:\\Dev\\JujuScripts\\games\\sound\\road.wav\")"
				//"fm(sin@0.1,fm(qud@0.2,qud)@0.5)"
				//"mix(mix(noise(0.5), noise(0.7))*0.5, fm(sin@0.1,fm(qud@0.2,qud)@0.25)*2)"
			//);//
					//(user.brake != 0 ? "mix(am(sin,noise(0.9))*0.5,noise(0.4))" : "noise(0.5)@0.5")
					//+ " * " + vol
					//+ " @ " + (int)(user.vel.Magnitude() * 300/normalSpeed + 1) 
				//);
				
			Dx.Play(g.sounds.road);
			Dx.Play(g.sounds.engine);
			SetMessage("sound on");
		}
	} */
	else if (key == 116)	// f5
	{
	
		g.auto = !g.auto;
		SetMessage(g.auto ? "autodrive" : "manual steer");
	}
	else if (key == 'G')
	{
	
		g.tint = 0.5;
		g.cycle = false;
		SetMessage("greyscale");
	}                 
	else if (key == 'H')
	{
	
		var tint = Math.(color(random(),random(),random());
		tint *= 1.0/tint.Brightness();
		g.tint = tint * 0.6;
		g.cycle = false;
		SetMessage("random palette");
	}
	else if (key == 'K')
	{
	
		g.cycle = !g.cycle;
		SetMessage("palette cycle " + (g.cycle ? "on" : "off" ));
	}
	/*else if (key == 'C')
	{
	
		scr.SetMonochrome(false);
	} */
	else if (key == 114)	// F3
	{
	
		g.showDashboard = !g.showDashboard;
		//scr.SetMonochrome(false);
		//g.cycle = false;
		SetMessage("dashboard " + (g.showDashboard ? "on" : "off" ));
	}                 
	/*else if (key == 'X')
	{
	
		g.xfunc = !g.xfunc;
	} */
	else if (key >= '1' && key <= '9')
	{
	
		g.roadType = key-'1';
		user.Init();
		road = MakeRoad();
		lastTime.GetLocal();
	}
	else 
	{
	
		//System.MessageBox(key);
		//win.FullScreen(true);
	}
	
	/*if (g.col.sky.Brightness() > 0)
	{
		scr.rgb = g.col.sky;
		
			// do sky?
		shape sh.MakeUnit();
		sh.Scale(point(scr.Width(), scr.Height() * 0.399));
		scr.Shape(sh);
	} */
	
	var lineThickness = scr.Width() * 0.0025;
	g.center.y = min(0.5, max(0.3, 1.0 - (scr.Width() * 0.5/scr.Height())));
	
		// now let's get the time step here
	time tm.GetLocal();
	real period = tm - lastTime;
	lastTime = tm;
	real step = period;
	
	if (step > 0.1)	// maximum frame step is 0.1 seconds
		step = 0.1;
	
	if (KeyPressed("shift"))// || Dx.JoystickButton(0))
		step *= 0.125;
	else if (KeyPressed("control"))// || Dx.JoystickButton(1))
		step *= 4;
		
		// soften it to deal with coarse timing issues
	step = mix(lastStep, step, 0.5);
	lastStep = step;
	

	point acc.Set(0,0);
	
	var joy = point(0,0);//Dx.Joystick();
	joy.x = mix(lastJoyX, joy.x, 0.5);
	lastJoyX = joy.x;
	
	joy.y = -joy.y;
	
	acc.y = joy.y;
	
	//if (g.auto)
//		acc.y += 1.0;
	
	var temp_steer = 0;//joy.x;
	
	//if (abs(acc.y) < 0.1)
		//acc.y = 0;
	

	if (KeyPressed("up") or KeyPressed('W'))
	{
	
		acc.y += 1;
	}
	if (KeyPressed("down") or KeyPressed('S'))
	{
	
		acc.y -= 2;
	}  
	
	//user.roadPos = 1;
	
	if (KeyPressed("left") or KeyPressed('A'))
	{
	
		if (g.auto)
		{
			//user.roadPos = 3;
			user.roadPos += 3 * step;
		}
		else
			temp_steer -= 1;
	}
	if (KeyPressed("right") or KeyPressed('D'))
	{
	
		if (g.auto)
		{
			//user.roadPos = -1;
			user.roadPos += -3 * step;
		}
		else
			temp_steer += 1;
	} 
	
	if (g.auto)
	{
		if (user.roadPos > 0.1)
			user.roadPos -= step;
		else if (user.roadPos < -0.1)
			user.roadPos += step;
	}
	
	int wanted = (int)(user.roadPos + 100.5) - 100;
	
	//user.roadPos = mix(user.roadPos, wanted, step);
		
	
		// read function keys      
	if (g.wireframe != KeyPressed("f2"))
	{
	
		g.wireframe = !g.wireframe;
		scr.Cmd("wireframe " + (g.wireframe ? "on" : "off"));
		SetMessage("wireframe " + (g.wireframe ? "on" : "off"));
	}  
	
	/*if (g.noAA != KeyPressed("f3"))
	{
	
		g.noAA = !g.noAA;
		scr.Cmd("aa " + (!g.noAA ? "on" : "off"));
	} */          
	
	
	//g.blur = KeyPressed("f4");
		
	//g.project = !KeyPressed("f5");
   g.rearView = KeyPressed("f4");
   if (g.rearView)
   	SetMessage("rear view");
      
   
	if (KeyPressed('B'))	// hi contrast
	{
	
		g.tint *= Math.pow(2, step);
		g.cycle = false;
	}
	if (KeyPressed('V'))	// lo contrast
	{
	
		g.tint *= Math.pow(2, -step);
		g.cycle = false;
	}
	
	/*
	if (KeyPressed("P"))
		g.fisheye = min(1.0, g.fisheye + 1.0 * step);
		
	if (KeyPressed("O"))
		g.fisheye = max(0.0, g.fisheye - 1.0 * step);
		*/
			
	/*if (KeyPressed("Q"))
	{
	                 
		user.lastVel.y += 20 * step;
		//user.pos.y *= 4`step;
	}                 
	if (KeyPressed("A"))
	{
	                 
		user.pos.y /= 4`step;
	} */                
	if (KeyPressed('M'))
	{
	
		g.zoom *= Math.pow(2, step);//1.01;
		SetMessage("zoom " + (int)(g.zoom * 100));
	}
	if (KeyPressed('N'))
	{
	
		g.zoom *= Math.pow(2, -step);//1.01;
		if (g.zoom < 0.125)
			g.zoom = 0.125;
		SetMessage("zoom " + (int)(g.zoom * 100));
	}
	
	if (KeyPressed("home"))
	{
	
		//user.Init();
		g.auto = true;
		user.roadPos = 0;
		user.PlaceOn(theRoad[0]);
		g.fade = 0;
		SetMessage("returned to road");
	}
	
	
	/*if (true)	// handle key input
	{
	
		if (true)//steer != 0)
		{
			var amount = step * ((user.steer * temp_steer < 0) ? 0.4 : 0.2);
			if (amount > abs(temp_steer - user.steer))
				user.steer = temp_steer;
			else
				user.steer += sign(temp_steer - user.steer) * amount;
		}
		else  // return
		{
			user.steer = mix(user.steer, temp_steer, 0.1);
		}
	} */
	
	user.brake = 0;
	user.accelerate = 0;
	
		
	if (KeyPressed(" "))
		user.brake = 1;
	
	//user.vel += acc;
	
	var xs = joy.x;
	
	if (g.xfunc)
	{
		xs = sign(xs) * 0.75 * (Math.pow(|xs, 3) + |xs * 0.25);	//mix(xs*0.5, xs, abs(xs));
	}
	else
	{
		xs *= 0.5;
	}
	
		
	
	//xs += user.steer;
	//user.steer = xs;
		
	/*
	real speed = user.vel.Magnitude();
	speed -= (((0.002*speed+0.01)*speed)+0.005) * step;
	
	if (speed < 0)
		speed = 0;
		
	user.vel = !user.vel*speed;
	*/
	var carCloseness;
	var closeness;
	for (var tt = step; tt > 0; tt -= g.timeSlice)
	{
		var step = min(tt, g.timeSlice);
		
		if (g.auto)   
			user.AutoDrive(theRoad[0]);
		else
		{
			var diff = -sign(user.steerTo) * 0.0002 * user.vel.Magnitude() * step;
			if (|diff >= |user.steerTo)
				user.steerTo = 0;
			else
				user.steerTo += diff;
				
			user.steerTo = user.steerTo + temp_steer * 0.025 * step;
		}
		
		user.accelerate += acc.y;
			
		user.steerTo += xs * 0.05;
	
		user.Advance(step);
		for (var o in other)
		{
			o.AutoDrive(theRoad[0]);
			//for (int j = i + 1; j < other.Length(); j++)
		//				c.Collide(other[j]);
				
			//c.Collide(theWalls);
			
			o.Advance(step);
			if (g.collisions)
			{
				var cc = user.Collide(o);
				if ((carCloseness is void) || cc < carCloseness)
					carCloseness = cc;
			}
		}
		
		if (g.collisions)
			closeness = user.Collide(theWalls);
	}
	
		
	
		
	user.steerTo -= xs * 0.05;
	
	if (g.cycle)	// cycle colors
	{
		real t = lastTime * 0.125;
		var tint1 = color(Math.sin(t * 0.7) * 0.5 + 0.5, Math.sin(t*0.9) * 0.5 + 0.5, Math.sin(t*1.3) * 0.5 + 0.5);
		//tint.b = 1 - max(tint.r,tint.g);
		
		tint1 *= 0.7 / tint1.Brightness();
		
		g.tint = tint1;
	}
	
	scr.Cmd("pattern zoom " + (Math.sin(lastTime * 0.1) * 0.1 + 1));	
	if (g.wireframe)
	{
		scr.bg = 0;
		scr.Cls();
	}
	else
	{
		scr.DrawBackground();
	}
	
		// draw the road itself
	scr.DrawSet(road);
	
		// draw the road itself
		
	if (false)	// draw signs
	{
		scr.rgb = 0;//color(0.5,0,0);//0.3;//color(0.5,1,0.5);
		//scr.DrawRoadShape(text);
		for (var t = 1; t < theRoad[0].Length(); t += 5)
		{
			vector position;
			position = theRoad[0].(GetPoint(t) + GetNormal(t) * 120);
			scr.DrawSign(signShape, position, -!theRoad[0].GetTangent(t) * 2);//vector(0,y,0));
		}
	}		
	
	shape carBodiesTop;
	shape carBodiesBottom;
	shape cars;
	shape lights;
	shape lightPaths;
	
	scr.rgb = 1;
	for (int i = g.project ? 0 : -1; i < other.Length(); i++)
	{
	
		var &c = i < 0 ? user : other[i];
		
		//if (g.project && (user.Dir() ^ !(c.pos - user.pos)) < 0.5)
			//continue;
			
		var dir = c.Dir();
		
		var a = carLights;
		a.Rotate(-c.angle);
		a.Move(W2M(c.pos));
		if (((user.pos - (c.pos + dir)) ^ dir) > 0)
			lights.Merge(a);
		else //if (((user.pos - (c.pos + dir)) ^ dir) < 0)
		{      
			var a = carTailLightShape;
			a.Rotate(-c.angle);
			a.Move(W2M(c.pos));
			cars.Merge(a);
		}
		
		var a = carBodyTop;
		a.Rotate(-c.angle);
		a.Move(W2M(c.pos));
		carBodiesTop.Merge(a);
		
		var a = carBodyBottom;
		a.Rotate(-c.angle);
		a.Move(W2M(c.pos));
		carBodiesBottom.Merge(a);
		
		var a = carLightPaths;
		a.Rotate(-c.angle);
		a.Move(W2M(c.pos));
		lightPaths.Merge(a);
	}
	
	if (true)
	{
		scr.rgb = g.col.ground;	// black bodies
		scr.alpha = 1;
		scr.DrawRoadShape(carBodiesTop, 2, 1.75);
		scr.DrawRoadShape(carBodiesBottom, 0.25, -1.75);
		
		//scr.alpha = 0.5;
		scr.rgb = 0.6;	// tail light?
		scr.alpha = 1;
		scr.DrawRoadShape(cars, 0.75, 0.2);
		
		/*scr.alpha = 0.1;
		scr.DrawRoadShape(cars, -0.8, 2);
		scr.DrawRoadShape(cars, -0.8, 1);
		scr.DrawRoadShape(cars, -0.8, 0.3);
		*/
		
		scr.alpha = 1;
		
		scr.rgb = 1.0;	// head light?
		scr.alpha = 1;
		
		scr.alpha = 1;
		scr.DrawRoadShape(lights, 1, 0.3);
		
		/*
		scr.alpha = 0.1;
		//scr.DrawRoadShape(lights, -3.5);
		scr.DrawRoadShape(lights, -0.7, 2);
		scr.DrawRoadShape(lights, -0.7, 1);
		scr.DrawRoadShape(lights, -0.7, 0.3);
		scr.alpha = 1;
		
		scr.alpha = 0.125;
		lightPaths.MakeBendy();
		lightPaths.MakeBendy();
		scr.DrawRoadShape(lightPaths, 0, 0);
		scr.alpha = 1;
		*/
	}
	   
	
	var nearest = theRoad.GetNearestPoint(user.pos);
	
	var normalSpeed = 100 * 1000 / 3600;	// 100 km/h
	//roadSound.SetSpeed(user.vel.Magnitude()/normalSpeed + 0.001);
	
	var vol = g.area;
	if (closeness is float)
	{	 
		if (closeness > 2)
			vol += 2.0/closeness;
		else 
			vol += 1;
	}
	
	if (carCloseness is double)
	{	 
		if (carCloseness > 4)
			vol += 4.0/carCloseness;
		else 
			vol += 1;
	}

	if (vol < 0.0)
		vol = 0;
	else if (vol > 1.0)
		vol = 1.0;		
	//vol = Math.pow(vol, 0.5) * 0.5;
	
	//roadSound.SetVolume(mix(0.5, 1, vol));
	
	if (!g.mute)
	{
		var speed = user.vel.Magnitude()/normalSpeed;
		with g.sounds.road {
			SetScale(speed);
			SetAmplitude(vol);
			}
			
		with g.sounds.engine {
			SetScale(speed);
			//SetAmplitude(vol);
			}
		/*
		Dx.SetSignal(CreateSignal(
				(user.brake != 0 ? "mix(am(sin,noise(0.9))*0.5,noise(0.4))" : "noise(0.5)@0.5")
				//+ " * " + vol
				+ " @ " + (int)(user.vel.Magnitude() * 300/normalSpeed + 1) 
		));
		*/
	} 
	
	//g.areaLast = mix(g.areaLast, g.area, 0.1);
	g.area = 0;
	
	if (g.project && g.showDashboard && !g.rearView)	// draw controls
	{
	
		var dwidth = scr.Width();
		var dheight = scr.Height();
			
		scr.alpha = 1;
		
		color fill = 0;//g.col.sky * 0.5;
		color line = 0.2;
		color shadow = 0;
		
		var thick = lineThickness * 4;
   
		shape sh.MakeCircle(point(0,0), 1);
		sh.Scale(point(1.2,0.3) * dwidth);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.2 : 0.8), dheight * 1.05));
		scr.rgb = fill;
		
		if (false)
		{
			var go = scr.( point(Width()*0, Height()*1) );
			var gx = scr.( point(Width(), 0));
			var gy = gx.RotateCW() * 0.5;// scr.( point(Width(), 0) * 0.5);
			scr.rgb = 0.2;
			scr.bg = 0.2;
			scr.Cmd("pattern gradient linear org %g %g dx %g %g dy %g %g" << [go.x, go.y, gx.x, gx.y, gy.x, gy.y]);
		}
		
		scr.Shape(sh);
		scr.Cmd("pattern");
		
		sh.Outline(thick);
		scr.rgb = line;
		scr.Shape(sh);
		
			// do speedo
		scr.rgb = line;
		
		var sh = speedoShape;
		sh.Scale(point(1,1) * dwidth * 0.2);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.325 : 0.675), dheight * 0.875));
		scr.Shape(sh);
		
		var sh = speedoShape;
		sh.Scale(point(1,1) * dwidth * 0.2);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.1 : 0.9), dheight * 0.875));
		scr.Shape(sh);
		
		real speed = user.vel.Magnitude() / 1000 * 3600;
		speed = mix(-Math.PI * 0.8, Math.PI * 0.8, min(speed/400, 1));
		var sh = speedoNeedle;
		sh.Scale(point(1,1) * dwidth * 0.2);
		sh.Rotate(speed);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.325 : 0.675), dheight * 0.875));
		scr.rgb = line;
		scr.Shape(sh);
		
		real speed = g.frameRate;
		speed = mix(-Math.PI * 0.8, Math.PI * 0.8, min(speed/80, 1));
		var sh = speedoNeedle;
		sh.Scale(point(1,1) * dwidth * 0.2);
		sh.Rotate(speed);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.1 : 0.9), dheight * 0.875));
		scr.rgb = line;
		scr.Shape(sh);
		
			// do steeringwheel
		var sh = steeringWheelShape;
		sh.Rotate(user.steerPos * 50);
		sh.Scale(point(1,1) * dwidth * 0.9);
		sh.Move(point(dwidth * (g.laneOffset < 0 ? 0.2 : 0.8), dheight * 1.1));
		if (true)
		{
		
			scr.rgb = line;
			//scr.alpha = 0.2;
			//scr.Shape(sh);
			var s2 = sh;
			s2.Move(point(0, -thick*0.5));
			s2.Expand(-thick*0.5);
			sh.Expand(thick*0.5);			
			//sh.Outline(thick);
			scr.rgb = line;
			scr.Shape(sh);
			if (shadow != fill)
			{
				scr.rgb = shadow;
				sh.Scale(point(1.1,1.3));
				scr.alpha = 0.25;
				scr.Shape(sh);  
				scr.alpha = 1;
			}              
			
			scr.rgb = fill;
			scr.Shape(s2);
			scr.Cmd("pattern");
			//scr.alpha = 0.2;
			//scr.Shape(sh);
		}
		else
		{
		
			scr.rgb = fill;
			//scr.alpha = 0.2;
			scr.Shape(sh);
			
			sh.Outline(thick);
			scr.rgb = line;
			scr.Shape(sh);
			//scr.alpha = 0.2;
			//scr.Shape(sh);
		}
		scr.alpha = 1;
		
	}
	
	//pos = theRoad.GetNearest(pos);
		
	if (g.blur)
		scr.Cmd("blur x3 y3");//x3 y3");
		
	
	g_frameInterval = mix(g_frameInterval, period, 0.01);
	//g_startTime = tm;
	
	g.frameRate = 1.0/g_frameInterval;
	
	if (g.showHelp > 0)
	{
	
		g.showHelp -= 0.5 * step;
		DrawHelp();
	}
	
	
	/*
	shape b = banner;
	b.Scale(point(scr.Width() * 0.025, scr.Height() * 0.5));
	b.Move(point(scr.Width() * 0.975,0));
	//b.Scale
	scr.rgb = 1;
	scr.Shape(b);
	*/
		
	if (g.wireframe)
	{
	 
		var t = color(0,0,0.5);
		scr.SetTint(t, mix(t,1,0.75), 1);
	}
	else
	{
		color fw = 0 * g.fade;
		color fl = g.tint * g.fade;
		color fh = 1 * g.fade;
		
		if (g.fade < 1)
			g.fade = mix(1, g.fade, 0.8/2`period);
		
		if (g.fade > 1)
			g.fade = 1;
		
		scr.Cmd("tint lo 0 hi 255 #%06X #%06X #%06X" << [fw.Get32(), fl.Get32(), fh.Get32()]);
		//scr.Cmd("tint lo 128 hi 255 0 #%06X #%06X" << [fh.Get32(), fw.Get32()]);
		
	}
	win.Paint();
	
	g_frames++;
}

function screen::DrawBackground()
{
	alpha = 1;
	bg = g.col.ground;//g.project ? g.col.sky : g.col.ground;
	Cls();
	
	if (!g.project)	// || g.col.sky == g.col.ground)
		return;
	
	var center = point(Width() * g.center.x, Height() * g.center.y);
	
	shape sh;//.MakeUnit();
	
	//for (int i = 1; i < 10; i++)
	//	sh.AddControl(point(i / 10.0, 0));
		
	sh.AddVertex(point(1,0));
	sh.AddVertex(point(1,1));
	sh.AddVertex(point(0,1));
	sh.AddVertex(point(0,0));
	
	sh.Move(point(-0.5,0.0001));
	sh.Scale(point(-1,1));
	//sh.Move(point(0,-0.02));
	
	vector vo.Set(0,0,g.rearView ? -0.01 : 0.01);
	vector vx.Set(1,0,0);
	vector vy.Set(0,1,0);	// vertical
	
	var tilt = user.tilt * Math.PI
	var pitch = -user.pitch * Math.PI;
	var zoom = 1.0/(g.rearView ? -g.zoom : g.zoom);
	
	with (vo,vx,vy)
		this = RotateZ(tilt).RotateX(pitch);
	
	with (vo,vx,vy)
	{
		z *= zoom;
		y = -y;
		if (g.rearView)
			x = -x;
	}
	
	sh.Project(vo, vx, vy);
	
	var scale = max(center.x, center.y);
	
	point gradTop = (vo + vy * 0.015).( this / z);
	point gradOrg = vo / vo.z;
	gradTop -= gradOrg;
	gradTop *= scale;
	gradOrg *= scale;
	gradOrg += center;
	
	sh.Scale(scale);
	
	//sh.Rotate(user.tilt * Math.PI);
	sh.Move(center);
	
	bg = g.col.sky.hi;//ground;
	rgb = g.col.sky.lo;
	
	if (g.gradient)
		Cmd("pattern gradient linear power %g org %g %g dx %g %g" << [g.col.sky.gradient, gradOrg.x, gradOrg.y, gradTop.x, gradTop.y]);
	else
		rgb = (g.col.sky.hi + g.col.sky.lo) * 0.5;	// average the two
		
	Shape(sh);
	Cmd("pattern"); 
}

function screen::DrawRoadShape(&sh) { DrawRoadShape(sh, 0.0, 0.0); }

function screen::DrawRoadShape(sh, real height, real extr)
{
	if (height > 0)
		Cmd("pattern"); 
	
	var center = point(Width() * g.center.x, Height() * g.center.y);
	if (g.project)
	{
		var up = user.pos;//vector up.Set(user.pos.x, 0, user.pos.y);
		
		vector vo.Set(0,height,0);
		vector vx.Set(1,0,0);
		vector vy.Set(0,0,1);
		
		vo -= up;
		
		var yaw = user.angle;
		var tilt = user.tilt * Math.PI;
		var pitch = -user.pitch * Math.PI;
		
		with (vo,vx,vy)
			this = RotateY(yaw).RotateZ(tilt).RotateX(pitch);
		
		vector vz = (vx * vy) * extr;
			
			// factor in zoom here now
		var zoom = 1.0/(g.rearView ? -g.zoom : g.zoom);
		
		with (vo,vx,vy,vz)
		{
			z *= zoom;
			if (g.rearView)
				x = -x;
		}
		
		if (extr != 0)
			sh.Project(vo, vx, vy, vz);
		else                         
			sh.Project(vo, vx, vy);
		
		g.area += |sh.GetArea() * rgb.(r+g+b) * 0.33333333333;
		
		//if (g.fisheye > 0)
			//sh.Fisheye(g.fisheye);
			
			// make sure positive y is up
		sh.Scale(point(1,-1) * max(center.x, center.y));// * g.zoom);
		
		//if (rgb.r > 0.5 && extr != 0)	// bright?
		  //sh.Expand((height < user.pos.y ? -1 : 1) * 0.5);
		
		//sh.Rotate(user.tilt * Math.PI);
		sh.Move(center);
	}
	else
	{
	
		sh.Move(-W2M(user.pos));
		sh.Rotate(user.angle);
		sh.Scale(point(30,-30) * (center.x + center.y) * 0.0025 / (user.pos.y * 0.05 + 4));
		center = point(Width() * 0.5, Height() * 0.6);
		sh.Move(center);
	}

	//sh.Outline(1);	
	Shape(sh);	
}

function screen::DrawSet(set)
{
	for (int i = 0; i < set.Length(); i++)
	{
	
		var& a = set[i];
		rgb = a.rgb;
		alpha = a.alpha;
		
		DrawRoadShape(a, a.height, a.extrude);
	}

	rgb = 1;
	alpha = 1;
}

function screen::DrawSign(sh, vo, normal)
{
	//if (!g.project)
		//return;
	if (!g.project)
		return;
		
	//vector v.Set(pos.x,0,pos.y);
	//vector vx.Set(1,0,0);
	var up = user.pos;
	vector vy.Set(0,1,0);
	vector vx = normal;//.Rotate(user.angle);
	swap(vo.y, vo.z);
	swap(vx.y, vx.z);
	
	vo -= up;
	
	vo = vo.RotateY(user.angle);
	vx = vx.RotateY(user.angle);
	vy = vy.RotateY(user.angle);
	
	vo = vo.RotateZ(-user.tilt * Math.PI);
	vx = vx.RotateZ(-user.tilt * Math.PI);
	vy = vy.RotateZ(-user.tilt * Math.PI);
	
	var pitch = user.pitch * Math.PI;
	vo = vo.RotateX(pitch);
	vx = vx.RotateX(pitch);
	vy = vy.RotateX(pitch);
	
   var vz = vx * vy * 0.1;
		// don't bother drawing?
	//if (v.z <= 0)
		//return;
		
	var zoom = 1.0/(g.rearView ? -g.zoom : g.zoom);
	vo.z *= zoom;
	vx.z *= zoom;
	vy.z *= zoom;
	vz.z *= zoom;
	
	sh.Project(vo, vx, vy, vz);
	
	//if (g.fisheye > 0)
		//sh.Fisheye(g.fisheye);
		
	var center = point(Width() * g.center.x, Height() * g.center.y);
	sh.Scale(point(1,1)* center.x);// * g.zoom);
	sh.Move(center);

	Shape(sh);	
}                

function MakeRoad()
{
	ShowTitle();
	g.auto = true;
	g.laneSpacing = 4;
	theWalls.Init();
	with theRoad
	{ 
		Init();
		int n = 16;
		for (int i = 0; i < n; i++)
		{
			real theta = i * Math.PI * 2 / n;
			var pt = point(Math.cos(theta), Math.sin(theta)) * (Math.random() + 5); 
			//var pt = point(Math.cos(theta), Math.sin(theta)) * (Math.sin(theta * 5) + 12); 
			AddControl(pt);
		}
		//this[0].ConvertType(1);
		
		BoxFit();
		//Move(-this[0].GetPoint(0));
		Scale(point(400,400));
		ReCenter();
	}
	
	var& p = theRoad[0];
	
	part set[];
	
	var &layer = set.Next();
	
	//layer = part;
	//part layer;
	
	g.tint = 0.5;
	g.col.ground = 0.0;
	g.col.sky.lo = 0.75;
	g.col.sky.hi = 0.25;
	g.col.sky.gradient = 0.5;
	
	if (g.roadType == 1)	// tunnel
	{
		SetMessage("(tunnel)");
		g.tint = color(0.2, 0.7, 0.1);
		g.col.sky.lo = g.col.sky.hi = 0;
		var tarmac = 0.1;
		//g.tint.lo = 0.5;
		//g.tint.hi = color(1,1,0);
		var whiteLines = 0.8;
		var yellowLines = 0.75;
		var lightColor = 1;
		//g.col.sky = g.col.ground = 0.4;
		
			// do underlays
		//layer.rgb = 0.25;     
		//layer.Merge(MakeRoadLine(p, 0, 8, 60, 0));//2, 8));//20, 0.5));
		
			// do white lines
		var &layer = set.Next();
		layer.rgb = tarmac;
		layer.Merge(MakeRoadLine(p, 0, 7, 30, 0));
		
		var &layer = set.Next();
		layer.rgb = whiteLines;
		layer.Merge(MakeRoadLine(p, -3.5, 0.2, 30, 2));
		layer.Merge(MakeRoadLine(p, 3.5, 0.2, 30, 2));
		layer.Merge(MakeRoadLine(p, -0.15, 0.15, -4, 8));
		
			// do yellow lines
		var &layer = set.Next();
		layer.rgb = yellowLines;
		layer.Merge(MakeRoadLine(p, 0.125, 0.125, 30, 0));
		
			// do crossings
		if (true)
		{
			var &layer = set.Next();
			layer.rgb = tarmac;//g.col.ground;
			layer.Merge(MakeRoadLine(p, 0, 1, -2, 200));//2, 8));//20, 0.5));
			layer.Expand(1);
			
			var &layer = set.Next();
			layer.rgb = whiteLines;
			for (int i = 0; i < 6; i++)
			{
				var width = 6.0 / 6 * 0.5;
				layer.Merge(MakeRoadLine(p, i * 2 * width - 3 + width, width, -2, 200));//2, 8));//20, 0.5));
			}
		}
		
			// do lights
		if (true)
		{
			var &layer = set.Next();
			layer.rgb = lightColor;
			
			layer.height = 4;
			layer.extrude = 0.1;
			layer.Merge(MakeRoadLine(p, -4, 0.1, -4, 6));
			layer.Merge(MakeRoadLine(p, 4, 0.1, -4, 6));
			
			/*var &layer = set.Next();
			layer.rgb = color(0.5,0.5,0);
			layer.height = 4;
			layer.extrude = 0.2;
			layer.Merge(MakeRoadLine(p, 0, 0.4, 0, 90));
			
			var &layer = set.Next();
			layer.rgb = color(1,1,0);
			layer.height = 4;
			layer.extrude = 0.2;
			layer.Merge(MakeRoadLine(p, 0, 0.1, 0, 90));
			*/
		}
			// do black barriers
			/*
		var &layer = set.Next();
		layer.rgb = 0.25;
		layer.height = 4;
		layer.extrude = 4;
		layer.Merge(MakeRoadLine(p, -5, 0.2, 100, 0));
		layer.Merge(MakeRoadLine(p, 5, 0.2, 100, 0));
		   */    
		   
		if (true)	// walls
		  
		  
		{
		  
			part layer;// = set.Next();
			layer.rgb = g.col.sky.lo;
			
			layer.height = 4;
			layer.extrude = 4;
			layer.Merge(MakeRoadLine(p, -5, 0.4, 100, 0));
			layer.Merge(MakeRoadLine(p, 5, 0.4, 100, 0));
			
			set += layer;
			//var &layer = set.Next();
			layer.rgb = g.col.sky.lo;
			
			layer.height = 0;
			layer.extrude = -4;
			layer.Merge(MakeRoadLine(p, -5, 0.4, 200, 0));
			layer.Merge(MakeRoadLine(p, 5, 0.4, 200, 0));
			//theWalls.Merge(this);//MakeRoadLine(p, -5, 0.4, 200, 0));
			set += layer;
		}
	}
	else 	if (g.roadType == 2)	// city
	{
		g.tint = color(0.3, 0.3, 0.7) * 1.5;

		SetMessage("(city)");
		//g.tint.lo = color(0.8, 0.25, 0.25);
		//g.tint.hi = color(0.75, 0.4, 0.25);
		p.Scale(2);
		
		//var sky = color(0.5, 0.3, 0);
		//g.col.sky = 0.7;//color(0.5, 0.3, 0);
		g.col.ground = 0.05;
		color lines = 0.6;//g.col.sky;
		color obc = g.col.ground;
		
		g.col.sky.(lo = 0.4, hi = 0.0);
		
		//g.col.sky = color(1,0.5,0);//0.6, 0.4, 0.2);//color(0.3,0.3,0.4);
		//g.col.ground = gnd;
		
		if (true)	// sky ?
		{
		
			with set.Next() {
				rgb = g.col.sky.(lo + hi) * 0.5;
				alpha = 1;
				height = 200;
				for (int i = 0; i < 100; i++)
				{
					shape sh;
					var p = Math.(point(random()-0.5, random()-0.5));
					if (p > 0.5 || p < 0.1)
						continue;
						
					p *= 8000;	
					if (p - GetNearestPoint(p) < 200)
						continue;
						
					sh.MakeCircle(p, 500);
					Merge(sh);
				}
				MakeBendy();
				Scale(2);
				height *= 2;
				}
		}
			// do bg
		if (false)
		{
			with set.Next() {
				rgb = gnd;
				height = 50;
				extrude = 50;
				Merge(MakeRoadLine(p, -200, 15, 0, 200));
				Merge(MakeRoadLine(p, 200, 15, 0, 150));
				}
		
			// do bg
			with set.Next() {
				rgb = gnd;
				height = 70;
				extrude = 70;
				Merge(MakeRoadLine(p, -160, 10, -20, 90));
				Merge(MakeRoadLine(p, 160, 20, -25, 85)); 
				Merge(MakeRoadLine(p, 260, 20, -25, 40)); 
				}
		
			// do bg
			with set.Next() {
				rgb = gnd;
				height = 40;
				extrude = 40;
				Merge(MakeRoadLine(p, -80, 20, -25, 150));
				Merge(MakeRoadLine(p, 80, 20, -20, 200)); 
				Merge(MakeRoadLine(p, 300, 20, -40, 100)); 
				}
		
			// do bg
			with set.Next() {
				rgb = gnd;
				height = 20;
				extrude = 20;
				Merge(MakeRoadLine(p, -80, 40, -20, 45));
				Merge(MakeRoadLine(p, 80, 40, -25, 40));
				}
		}		
		else
		{
		
			with shape box {
				MakeUnit();
				ReCenter();
				Scale(40);
				}
				
			with part l0
			{
				rgb = obc;
				height = 15;
				extrude = height;
			}
			with part l1
			{
				rgb = obc;
				height = 30;
				extrude = height;
			}
			with part l2
			{
				rgb = obc;
				height = 50;
				extrude = height;
			}
			with part l3
			{
				rgb = obc;
				height = 120;
				extrude = height;
			}
				
			var radius = 1800;
			for (int x = -radius; x < radius; x+= 150)
			{
			
				for (int y = -radius; y < radius; y+=150)
			   {
			   
					var pos = point(x+Math.random()*100,y+Math.random()*100);
					if (pos > radius)
						continue;
						
					var pt = p.GetNearestPoint(pos);
					if (pt - pos < 60)
						continue;
						
					shape s = box;
					s.Move(pos);
					if (Math.random() > 0.8)
						l0.Merge(s);
					else if (Math.random() > 0.5)
						l1.Merge(s);
					else if (Math.random() > 0.25)
						l2.Merge(s);
					else
						l3.Merge(s);
			   }
			}
			with (l1,l2,l3)
			{
				//theWalls.Merge(this);
				set += this;
			}
		}
		
		with set.Next() {
			rgb = obc;
			height = extrude = 10;
			Merge(MakeRoadLine(p, -16, 0.2, -0.2, 400));
			Merge(MakeRoadLine(p, -12, 0.2, -0.2, 400));
			Merge(MakeRoadLine(p, 12, 0.2, -0.2, 300));
			Merge(MakeRoadLine(p, 16, 0.2, -0.2, 300));
			theWalls.Merge(this);
			}
		with set.Next() {
			rgb = obc;
			height = 14, extrude = 4;
			Merge(MakeRoadLine(p, -14, 6, -0.2, 400));
			Merge(MakeRoadLine(p, 14, 6, -0.2, 300));
			}
			
		with set.Next() {
			rgb = lines;
			height = 0;
			Merge(MakeRoadLine(p, 0, 0.1, 60, 0));
			Merge(MakeRoadLine(p, 0.2, 0.1, 60, 0));
			Merge(MakeRoadLine(p, -6, 0.15, 30, 1));
			Merge(MakeRoadLine(p, 6, 0.15, 30, 1));
			}
		
		with set.Next() {
			height = 0;
			rgb = lines;
			//extrude = 0.05;
			Merge(MakeRoadLine(p, -3, 0.15, 3, 12));
			Merge(MakeRoadLine(p, 3, 0.15, 3, 12));
			}
	}
	else if (g.roadType == 3)	// industrial
	{
		SetMessage("(industrial)");
		//g.tint = color(0.75, 0, 0);
		//g.tint.hi = color(0.5, 0.5, 0.8);
		//g.tint.lo = color(1,1,0);
		//g.tint.hi = color(0.9, 0.7, 0.2);
		g.tint = color(0.7, 0.4, 0.1);
			
		g.col.sky.hi = 0.15;//color(0.5, 0.3, 0);
		g.col.sky.lo = 1.0;//color(0.5, 0.3, 0);
		g.col.sky.gradient = 0.25;
		
		g.col.ground = 0.05;
		color lines = 0.6;
		color obc = g.col.ground;
		
			// far off buildings
		if (true)
		{
			
				// very tall things
			with set.Next() {
				rgb = 1;
				height = 62;
				extrude = 2;
				Merge(MakeRoadLine(p, 300, 0.5, 0, 250));
				Merge(MakeRoadLine(p, 320, 0.75, 0, 250));
			}
			
			if (true)
			{
				var &layer = set.Next();
				layer.rgb = obc;
				layer.height = 60;
				layer.extrude = 60;
				layer.Merge(MakeRoadLine(p, 300, 0.5, 0, 250));
				layer.Merge(MakeRoadLine(p, 320, 0.75, 0, 250));
				layer.Merge(MakeRoadLine(p, 400, 8, 0, 240));
				layer.Merge(MakeRoadLine(p, 500, 8, 0, 240));
			}
			
				// medium buildings
			var &layer = set.Next();
			layer.rgb = obc;
			layer.height = 12;
			layer.extrude = 12;
			layer.Merge(MakeRoadLine(p, -80, 20, -40, 60));
			layer.Merge(MakeRoadLine(p, 180, 50, -40, 30));
			layer.Merge(MakeRoadLine(p, 300, 50, -20, 20));
			
			/*var &layer = set.Next();
			layer.rgb = obc;
			layer.height = 10;
			layer.extrude = 10;*/
			
			layer.Merge(MakeRoadLine(p, -100, 8, 0, 200));
			layer.Merge(MakeRoadLine(p, -60, 8, 0, 1500));
			layer.Merge(MakeRoadLine(p, 100, 8, 0, 140));
			layer.Merge(MakeRoadLine(p, 120, 8, 0, 220));
		}
		
			// do white lines
		if (true)
		{			
			with set.Next() {
				rgb = lines;
				Merge(MakeRoadLine(p, -3.5, 0.15, 60, 2));
				Merge(MakeRoadLine(p, 3.5, 0.15, 60, 2));
				Merge(MakeRoadLine(p, -0.15, 0.125, -4, 6));
				Merge(MakeRoadLine(p, 0.125, 0.125, 60, 0));
				}
				
				// do crossings
			if (true)
			{
				with set.Next() {
					rgb = g.col.ground;
					Merge(MakeRoadLine(p, 0, 1, -2, 200));//2, 8));//20, 0.5));
					Expand(1);
					}
					
				with set.Next() {
					rgb = lines;
					for (int i = 0; i < 6; i++)
					{
						var width = 6.0 / 6 * 0.5;
						Merge(MakeRoadLine(p, i * 2 * width - 3 + width, width, -2, 200));//2, 8));//20, 0.5));
					}
					}
			}
		}        
		
				// street lights
		if (true)
		{
		
			var left = 80;
			var right = 80;
			var thick = 0.2;
			var tall = 15;
			
			with set.Next() {
				rgb = obc;
				height = tall + thick;
				extrude = thick;
				Merge(MakeRoadLine(p, -5.6, 5, thick, left));
			 	}
			
			with set.Next() {
				rgb = obc;
				height = tall;
				extrude = tall;
				Merge(MakeRoadLine(p, -8, thick, thick, left));
				theWalls.Merge(this);
			   }
			
			with set.Next() {
				rgb = 1;
				height = tall;
				extrude = thick*2;
				Merge(MakeRoadLine(p, -4, 2, thick, left));
				}
		}     
		
			// overpasses
		if (true)
		{
		
			var depth = 8;
			var spacing = 300;
			var p2 = p;
			p2.Scale(point(1,1.5));
			
			with set.Next() {
				rgb = obc;
				height = 12;
				extrude = 2;
				Merge(MakeRoadLine(p2, 0, 162, -depth, spacing));
				Scale(point(1,1/1.5));
				}
				
			with set.Next() {
				rgb = obc;
				height = 10;
				extrude = 10;
				Merge(MakeRoadLine(p2, -100, 42, -depth, spacing));
				Merge(MakeRoadLine(p2, -40, 2, -depth, spacing));
				Merge(MakeRoadLine(p2, -10, 2, -depth, spacing));
				Merge(MakeRoadLine(p2, 10, 2, -depth, spacing));
				Merge(MakeRoadLine(p2, 40, 2, -depth, spacing));
				Merge(MakeRoadLine(p2, 200, 242, -depth, spacing));
				Scale(point(1,1/1.5));
			   }
			                                                          
			shape wall = MakeRoadLine(p2, -10, 2, -depth, spacing);
			wall.Merge(MakeRoadLine(p2, 10, 2, -depth, spacing));
			wall.Scale(point(1,1/1.5));
			theWalls.Merge(wall);
		}
		
				// various poles
		if (true)
		{	
			with set.Next() {
				rgb = obc;
				
				height = 12;
				extrude = 12;
				Merge(MakeRoadLine(p, -30, 0.25, 0, 90));
				
				Merge(MakeRoadLine(p, -40, 0.25, 0, 110));
				Merge(MakeRoadLine(p, 60, 0.25, 0, 60));
				
				Merge(MakeRoadLine(p, -50, 0.25, 0, 60));
				Merge(MakeRoadLine(p, -20, 0.125, 0, 100));
				Merge(MakeRoadLine(p, 20, 0.25, 0, 45));
				Merge(MakeRoadLine(p, 50, 0.125, 0, 50));
				Merge(MakeRoadLine(p, 70, 0.25, 0, 75));
				}
				
				// knobs
			
			with set.Next() {
				rgb = obc;
				height = 13;
				extrude = 1;
				//Merge(MakeRoadLine(p, -30, 0.1, 0, 90));
				Merge(MakeRoadLine(p, -40, 1, 0, 110));
				Merge(MakeRoadLine(p, 60, 1, 0, 60));
         	}
				// wires
				
			with set.Next() {
				rgb = obc;
				height = 11.25;
				extrude = 0.025;
				
				Merge(MakeRoadLine(p, -50, 0.025, -60, 0));
				Merge(MakeRoadLine(p, -20, 0.025, -100, 0));
				Merge(MakeRoadLine(p, 20, 0.025, -45, 0));
				Merge(MakeRoadLine(p, 50, 0.025, -50, 0));
				Merge(MakeRoadLine(p, 70, 0.025, -75, 0));
				}
			//layer.Merge(MakeRoadLine(p, 4, 0.4, 6, 4));
		}
				// fencing
		if (true)
		{
			var tall = 5;
			var spacing = 30;
			var dist = 25;
			
			with set.Next() {
				rgb = obc;
				height = tall;
				extrude = tall;
				
				Merge(MakeRoadLine(p, -dist, 0.1, 0, spacing));
				Merge(MakeRoadLine(p, dist, 0.1, 0, spacing));
				}
			
			with set.Next() {
				rgb = obc;
				height = tall-0.5;
				extrude = 0.1;
				
				Merge(MakeRoadLine(p, -dist, 0.1, -spacing, 0));
				Merge(MakeRoadLine(p, dist, 0.1, -spacing, 0));
				//Merge(MakeRoadLine(p, -130, spacing * 5, -0.1, spacing * 5));
				//Merge(MakeRoadLine(p, 130, spacing * 5, -0.1, spacing * 5));
				}
			
			with set.Next() {
				rgb = obc;
				alpha = 0.25;
				height = tall - 0.6;
				extrude = tall - 0.6;
				
				Merge(MakeRoadLine(p, -dist, 0.1, -spacing, 0));
				Merge(MakeRoadLine(p, dist, 0.1, -spacing, 0));
				theWalls.Merge(this);
				}
		}
		
		
		//scr.SetTint(0, color(0xff, 0x0, 0x0) * 0.7 / 256.0, 1);
		//scr.SetTint(0, color(0x88, 0xcc, 0x88) * 0.7 / 256.0, 1);
	}
	else 	// ordinary road
	{
	
		SetMessage("(very sparse road)");
		g.tint = 0.7;
		g.col.(ground = sky.(hi = lo = 0));
		//g.col.ground = 0.075;
		color lines = 0.75;
		
		theRoad.Scale(2);
		layer.rgb = lines;
		layer.height = 0;
		//layer.extrude = 0.0125;
		
		layer.Merge(MakeRoadLine(p, 0, 0.2, 4, 10));
		layer.Merge(MakeRoadLine(p, -3, 0.15, 30, 2));
		layer.Merge(MakeRoadLine(p, 3, 0.15, 30, 2));
		
			// posts
		if (true)
		{
			with set.Next()
			{
				rgb = lines;
				height = 0.6;
				extrude = 1;
				Merge(MakeRoadLine(p, -6, 0.2, 0.2, 50));
				Merge(MakeRoadLine(p, 6, 0.2, 0.2, 50));
			}
		}
		
		scr.SetTint(0, 0.6, 1);
	}
	            
	
	var scale = vector(1.25,1.25,1);
	theRoad.Scale(scale);
	theWalls.Scale(scale);
	for (int i = 0; i < set.Length(); i++)
	{
	
		with set[i] {
			Scale(scale);			
			height *= scale.z;
			extrude *= scale.z;
			}
	}  
	
	user.PlaceOn(theRoad[0]);
	other.Resize(0);
	for (0)
		AddNPCCar();
		
	return set;//layer;
}

function MakeRoadLine(path p, var xpos, var width, var dashOn, var dashOff)
{
	bool smooth = dashOn > 0;
	dashOn = |dashOn;
	shape sh;
	bool on = true;
	real begin = 0; 
	real end = p.Length();
	for (real t0 = begin; t0 < end; )
	{
	
			// we need to establish an interval t0-t1 of the desired length
		var t1;
		
	 	if (on && dashOn == 0)
	 		t1 = t0;
	 	else
	 	{
	 		t1 = p.StepInterval((on ? dashOn : dashOff), t0);
	 		if (t1 < 0 || t1 > end)
	 			t1 = end;
	 	}
	 	
		var p0 = p.GetPoint(t0);
	 	var p1 = p.GetPoint(t1);
		
		if (on)
		{
			var x0 = p.GetNormal(t0);
			var x1 = p.GetNormal(t1);
			if (dashOn == 0)	// special case?
			{
			
				shape c.MakeCircle(p0 + x0 * xpos, width);
				sh.Merge(c);
				/*
				p0 = p0 + x0 * xpos;
				sh.AddControl(p0 + point(-1,-1) * width);
				sh.AddControl(p0 + point(1,-1) * width);
				sh.AddControl(p0 + point(1,1) * width);
				sh.AddControl(p0 + point(-1,1) * width);
				sh.ClosePath();
				*/
			}
			else
			{
					// calculate how many mid points are needed
				int between = smooth ? dashOn * 0.5 : 0;
				//p0.Set(0,0);
				//p1.Set(0,1);
				
				sh.AddVertex(p0+x0*(xpos-width*0.5));
				sh.AddVertex(p0+x0*(xpos+width*0.5));
	
				for (int i = 0; i < between; i+=1)
				{
			
					var t = mix(t0,t1,(real)(i+1)/(between+1));
					var pt = p.GetPoint(t) + p.GetNormal(t)*(xpos+width*0.5);
					sh.AddControl(pt);
				}			
				
				sh.AddVertex(p1+x1*(xpos+width*0.5));
				sh.AddVertex(p1+x1*(xpos-width*0.5));
				
				for (int i = 0; i < between; i+=1)
				{
			
					var t = mix(t1,t0,(real)(i+1)/(between+1));
					var pt = p.GetPoint(t) + p.GetNormal(t)*(xpos-width*0.5);
					sh.AddControl(pt);
				}			
				
				sh.ClosePath();
			}
		}  
		
		t0 = t1;
		
		if (dashOff > 0)
			on = !on;
	}
	return sh;
}

function MakeSign(shape sh)
{
	if (false)	// circle?
	{
		sh.ReCenter();
		rect rc = sh.GetRect();
		var m = rc.Width() * 0.6;
		shape ret;
		ret.MakeCircle(rc.Center(), m);
		ret.Outline(-m * 0.1);
		ret.Merge(sh);
		ret.BoxFit();
		ret.ReCenter();
		ret.Move(point(0,-2));
		return ret;		
	}
	else	// rectangle
	{
	
		sh.ReCenter();
		rect rc = sh.GetRect();
		shape ret.MakeUnit();
		ret.Scale(rc.hi * 2);
		ret.Move(-rc.hi);
		
		ret.Expand(0.2);
		//ret.Outline(0.05);
		//sh.Invert();
		
		ret = sh;//.Merge(sh);
		ret.ReCenter();
		ret.Move(point(0,-0.25));
		ret.Scale(point(10,40));
		return ret;		
	}
}

function shape::ReCenter()
{
	Move(-GetRect().Center());

}

function shape::BoxFit()
{
	rect rc = GetRect();
	if (rc.IsEmpty())
		return;

	Move(-rc.lo);
	var scale = rc.hi - rc.lo;
	
	if (scale.x > 0)
		scale.x = 1.0/scale.x;
		
	if (scale.y > 0)
		scale.y = 1.0/scale.y;
		
	Scale(scale);

}
function shape::AddVertex(x,y)
{
	AddVertex(point(x,y));

}
function shape::AddControl(x,y)
{
	AddControl(point(x,y));

}

time finishTime.GetLocal();

return 0;//g_frames/(finishTime - g_startTime);